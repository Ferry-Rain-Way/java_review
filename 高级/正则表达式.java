(1)为什需要正则表达式?

      |-- 1.正则表达式应用场景
            文本编辑器的搜索
            登录网站、输入密码时的验证
            判断是否是微信号、手机号、邮箱、纯数字
            ....

      |-- 2.概念
            正则表达式是对字符串操作的一种逻辑公式，
            就是用事先定义好的一些特定字符、及这些特定字符的组合，
            组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种"过滤逻辑"

            /*MyNote：
            字符串的格式匹配 -- 用特殊的字符串A 去匹配字符串B【C、D 】
            */

      |-- 3.起源
            正则表达式实际上是一门独立的学科，大部分编程语言都支持正则表达式。
            //但每种语言的正则表达式之间有细微的差别
            正则表达式最初使用在"医学"方面，用来表示神经符号等。目前使用最多
		      的是计算机编程领域，用作字符串格式匹配。包括搜索方面等。

           [百度百科](https://baike.baidu.com/item/正则表达式)

      |-- 4.特点
           1-灵活性、逻辑性和功能性非常的强；
           2-可以迅速地用极简单的方式达到字符串的复杂控制。
           3-对于刚接触的人来说，比较晦涩难懂。


(2)正则表达式在"java"中的语法
      |-- 1.java.util.regex 包主要包括以下三个类：
            ->Pattern 类：【模式类】
                  pattern 对象是一个正则表达式的编译表示。Pattern 类没有公共构造方法。
                  要创建一个 Pattern 对象，你必须首先调用其公共静态编译方法，它返回一个 Pattern 对象。
                  该方法接受一个正则表达式作为它的第一个参数。

            ->Matcher 类：【匹配器类】
                  Matcher 对象是对输入字符串进行解释和匹配操作的引擎。
                  与Pattern 类一样，Matcher 也没有公共构造方法。
                  你需要"调用 Pattern 对象"的 matcher 方法来获得一个 Matcher 对象

            ->PatternSyntaxException：【异常类】
                  PatternSyntaxException 是一个非强制异常类，它表示一个正则表达式模式中的语法错误。

          "  注意: 正则表达式写好后，没有错对之分，返回结果只是true和false"

(3)如何使用正则表达式
      |-- 1.案例分析:
                  //内容
                  Stringcontent="1998这是一2188个字符串123heihei空间！@8976与777好8888YU";
                  Stringregstr="\\d\\d\\d\\d";
                  //2创建模式对象[即正则表达式对象]
                  Patternpattern=Pattern.compile(regstr);
                  //3.创建匹配器
                  //说明:创建匹配器matcher，按照正则表达式的规则去匹配content字符串
                  Matcherm=pattern.matcher(content);
                  //4.开始匹配
                  while(m.find()){
                  System.out.println("Find:"+m.group(0));}


      |-- 2.深入了解：
            ->m.find()完成的操作以及group[0]的含义
                  1.根据指定的规则,定位满足规则的子字符串(比如1998)
                  2.找到后，将子字符串的开始的索引记录到Matcher对象m的属性int[] groups;
                        groups[0] = 0 ,把该子字符串的结束的索引+1的值记录到groups[1] = 4
                  3.同时记录oldLast的值为子字符串的结束的索引+1的值即4， 即下次执行find时，就从4开始匹配

            ->源码
                  /**
                  源码:
                         public String group(int group) {
                                if (first < 0)
                                    throw new IllegalStateException("No match found");
                                if (group < 0 || group > groupCount())
                                    throw new IndexOutOfBoundsException("No group " + group);
                                if ((groups[group*2] == -1) || (groups[group*2+1] == -1))
                                    return null;
                                return getSubSequence(groups[group * 2], groups[group * 2 + 1]).toString();
                            }
                  */

           ->分析matcher.group(0)执行操作
                        String content = "1998这是一2188个字符串123heihei空间！@8976与777好8888YU";

                        【非分组情况：String regstr = "\\d\\d\\d\\d";】
                              第一次：
                                  根据groups[0]=0,groups[1] = 4 ,对[0,4)的位置进行截取返回 ->1998
                              第二次：
                                根据groups[0]=7,groups[1] = 11 ,对[0,11)的位置进行截取返回->2188
                                //注意此时下标任然是0,1但所针对范围改变
                        |---------------------------------------------------------------------------
                        第一个()为第一组,第二个()为第二组,以此类推
                              String content = "1998这是一2188个字符串123heihei空间！@8976与777好8888YU";
                              String regstr = "(\\d\\d)([a-zA-z]+)";
                              //2创建模式对象[即正则表达式对象]
                              Pattern pattern = Pattern.compile(regstr);
                              //3.创建匹配器
                              //说明:创建匹配器matcher， 按照 正则表达式的规则去匹配 content字符串
                              Matcher m = pattern.matcher(content);
                              //4.开始匹配
                              while (m.find()) {
                              System.out.println("Find: 0->" + m.group(0));
                              System.out.println("Find: 1->" + m.group(1));
                              System.out.println("Find: 2->" + m.group(2));
                              //System.out.println("Find: 3->" + m.group(3));//异常，下标越界 java.lang.IndexOutOfBoundsException: No group 3
                              }
                              /*---------------------
                              运行结果：
                                    Find: 0->23heihei
                                    Find: 1->23
                                    Find: 2->heihei
                                    Find: 0->88YU
                                    Find: 1->88
                                    Find: 2->YU

                                    分析23heihei
                                    groups[0]:16    groups[1]:24
                                    groups[1]:16    groups[1]:18
                                    groups[2]:18    groups[2]:24

                                    分析:88YU
                                    groups[0]:39    groups[1]:43
                                    groups[1]:39    groups[1]:41
                                    groups[2]:41    groups[2]:43
                              ---------------------*/



(4)正则表达式--元字符
      |-- 1.转义号\\
            ->说明:在我们使用正则表达式去检索某些特殊字符的时候，需要用到转义符号，否
                        则检索不到结果，甚至会报错的。
                        案例:用$去匹配"abc$(" 会怎样?
                                    用(去匹配"abc$(" 会怎样?

            ->注意：【菜鸟教程】
                  在其他语言中，\\ 表示：我想要在正则表达式中插入一个普通的（字面上的）反斜杠，请不要给它任何特殊的意义。
                  在 Java 中，\\ 表示：我要插入一个正则表达式的反斜线，所以其后的字符具有特殊的意义。
                  所以，在其他的语言中（如 Perl），一个反斜杠 \ 就足以具有转义的作用，而在 Java 中正则表达式中则需要有
                  两个反斜杠才能被解析为其他语言中的转义作用。也可以简单的理解在 Java 的正则表达式中，
                " 两个 \\ 代表其他语言中的一个 \，这也就是为什么表示一位数字的正则表达式是 \\d，而表示一个普通的反斜杠是 \\"
                  /**MyNote:
                        简来说就是在java正则表达式中  "\\" 表示 请注意,我后面的是有特殊意义的字符了,例如：\\$
                  */

            ->常见的需要使用转义的字符
                        /      \      ()      []      {}

                        .      ?      $      *      +  ^

            注意："[]内的特殊字符不需要转义，他就代表普通字符"
      |-- 2.字符匹配符
            -> ----------------------------------------------------------------------------------------
                  [] -  ^      【列表、范围、反】
                  [xyz]      字符集。匹配包含的任一字符。例如，"[abc]"匹配"plain"中的"a"。
                  [^xyz]    反向字符集。匹配未包含的任何字符。例如，"[^abc]"匹配"plain"中"p"，"l"，"i"，"n"。
                  [a-z]      字符范围。匹配指定范围内的任何字符。例如，"[a-z]"匹配"a"到"z"范围内的任何小写字母。
                  [^a-z]    反向范围字符。匹配不在指定的范围内的任何字符。例如，"[^a-z]"匹配任何不在"a"到"z"范围内的任何字符。

            -> ----------------------------------------------------------------------------------------
                  .       任意字符     '\n'除外
                  \\d       数字[0-9]
                  \\D      非数字[^0-9]
                  \\w       数字、大小写字母、下划线[A-Za-z0-9_]//顺序也变,即：[0-9A-Za-z_]、[_a-zA-Z0-9]等表达相同含义
                  \\W      不是w匹配的内容[^A-Za-z0-9_]
                  \\s       空白字符
                  \\S      非空白字符
            ->----------------------------------------------------------------------------------------
                  (?i) 不区分大小写
                              "(?i)abc"       abc不区分大小写      可以匹配abc、ABC、Abc、aBc等
                              "a(?i)bc"      bc不区分大小写
                              "a((?i)b)c" 只有b不区分大小写
                              Pattern pattern = Pattern.compile(regstr,Pattern.CASE_INSENSITIVE);//不区分大小写

            ->----------------------------------------------------------------------------------------


      |-- 3.选择匹配符
                  | 或        例如："Ab|ac" 匹配Ab ac

      |-- 4.限定符:用于指定其前面的字符和组合项连续出现多少次
                  *            指定字符重复次数无要求
                  +            1次起步                            例如：m+(abc)+        以至少1个m开头，后接任意个abc的字符串-mmabc、mabcabc
                  ?            0-1
                  {n}       只能是n次
                  {n,}      n次起步
                  {n,m}    n-m次//注解①
                                    /**MyNote :
                                          注解①：java 匹配默认是贪婪匹配，即尽可能匹配长的
                                                      String content = "aaaaaa";
                                                      String regstr = "{3,4}";
                                                      结果为aaaa
                                                      匹配了一个aaaa ,不够在匹配一个aaa
                                    */
      |-- 5.定位符
                  ^      指定起始字符
                  $      指定结束字符
                  \\b 匹配目标字符串的边界：空格前、字符串的结尾
                              he\\b      ->hehu'he'    ss'he'-<有颜色表示匹配到
                  \\B 与\\b相反

      |-- 6.非贪婪匹配【?】
                  当此字符紧随任何其他限定符（*、+、?、{n}、{n,}、{n,m}）之后时，匹配模式是"非贪心的"。
                  "非贪心的"模式匹配搜索到的、尽可能短的字符串，而默认的"贪心的"模式匹配搜索到的、尽可能长的字符串。
                  例如，在字符串"oooo"中，"o+?"只匹配单个"o"，而"o+"匹配所有"o"



      |-- 6.分组捕获
            ->非命名分组
                  String regStr = "(\\d\\d)(\\d)"
            ->命名分组
                  (?<组名>表达式)
                        组名不能包含任何标点符号，并且不能以数字开头。可以使用单引替代尖括号

                        String regStr = "(?<group1>\\d\\d)(?<group2>\\d)"
                        ...
                        System.out.println("Find: 0->" + m.group(1));
                        或
                        System.out.println("Find: 0->" + m.group("group2"));

      |-- 7.非捕获分组
                  (?:pattern)
                        匹配 pattern 但不捕获该匹配的子表达式，即它是一个非捕获匹配，不存储供以后使用的匹配。
                        这对于用"or"字符 (|) 组合模式部件的情况很有用。
                        例如，'abcd(?:A|B|C)'是比 'abcdA|abcdB|abcdC' 更经济的表达式
                        //MyNote：需要注意的是该方法并不是真正意义上的分组,所以只能使用m.group(0)获取结果

                  (?=pattern)例如：'Windows (?=95|98|NT|2000)' 匹配"Windows 2000"中的"Windows"，但不匹配"Windows 3.1"中的"Windows"。

                  (?!pattern)例如：'Windows (?!95|98|NT|2000)' 匹配"Windows 3.1"中的 "Windows"，但不匹配"Windows 2000"中的"Windows"







/**MyNote:
            w,Word,单词.\w匹配包括下划线的任何单词字符.等价于'[A-Za-z0-9_]'
            s,Space,空白,空格.\s匹配任何空白字符,包括空格、制表符、换页符等等.等价于 [ \f\n\r\t\v]
            b,boundary,边界,界限.\b匹配一个单词边界,就是...比如've\b',可以匹配love里的ve而不匹配very里有ve
            d,Digital,数字的.\d匹配一个数字字符.等价于 [0-9]
            r,return,回车.\r匹配一个回车符.等价于 \x0d 和 \cM
            t,tabulator key,制表符.匹配一个制表符.等价于 \x09 和 \cI
            v,Vertical,垂直（制表符）匹配一个垂直制表符.等价于 \x0b 和 \cK
            u,Unicode,Unicode字符
            c,Control,控制
            f,Form-feed,换页
            n,liNe feed.换行
            Num,数字（正整数）
            x,heX,十六进制
*/

手机号:1开头、长度11、必须全是数字
^1\\d{10}$
邮箱:
      开头字母，数字，必须包含@
      一个字母数字长度2-5一个字母

密码:必须字母开头，中间可以是字母数字，长度6-16
^[a-zA-z]{1}[a-zA-Z0-9]{5,15}$



1. 汉字
基本汉字Unicode 编码4E00-9FA5
^[\u4E00-\u9FA5]+$
2.
邮政编码
要求:是1-9开头的一个六位数.比如: 123890
^[1-9]{1}\\d{5}$


3. QQ号码
要求:是1-9开头的一个(5位数- 10位数)比如: 12389 , 1345687 , 187698765
^[1-9]{1}\\d{4,9}$



4.手机号码
要求:必须以13,14,15, 18开头的11位数,比如13588889999
^1[3|4|5|8]\\d{9}$


5. URL: 如图:



